[{"title":"","date":"2017-04-09T06:47:07.365Z","path":"2017/04/09/JS之类数组转换数组的2种方式 /","text":"JS之类数组转换数组的2种方式 在转换之前，我们应该先了解一下数组与伪数组的基本格式。 1.数组的标准格式1234567891011var arr = [ 0 : \"aaa\", 1 : \"bbb\", 2 : \"ccc\", length : 3, __proto__: &#123; push : function push(), slice : function slice(), ... &#125;] ​ 由上可知，push和slice是数组的原型对象上的方法。使用代码如下：123456789101112131415// 数组的用法var arr = [1,23,4,2,3,4];console.log(arr);arr.push(\"hello\"); // push():向数组的末尾追加一项数据，返回的是数组的新长度console.log(arr.length); // 7// 如果把数组当成对象arr.abc = 123; //此时数组为对象，该语句表示向数组增加一个名为abc的属性，数组长度不会改变console.log(arr.length); // 7arr[\"attr\"] = 232; // 同上，增加新属性arr[9] = 342; // 如果[]内是数字，则表示向数组的某一项赋值，此时数组的长度为10。console.log(arr.length); // 10console.log(arr[8]); //undefinedvar narr = arr.slice(0, 2); //从数组中返回选定长度的元素arr.slice(startIndex,endIndex)，如果只有一个参数，表示节选从startIndex到数组的末尾的元素。 2.类数组的格式 结构与数组相似的对象，拥有索引和长度，但是不具有数组的方法1234567var obj = &#123; 0 : \"ad\", 1 : \"ae\", 2 : \"erf\", 3 : \"wer\", length : 4&#125; 将伪数组转换成数组的两种方式 借助数组的原型上的方法：slice()和slice() 通过call/apply调用函数，改变所调用函数的this指向，将伪数组转换成数组 1234567891011121314151617 var obj = &#123; 0 : \"ad\", 1 : \"ae\", 2 : \"erf\", 3 : \"wer\", length : 4 &#125; // 方法一：slice()var arr1 = [].slice.call(obj, 0); // obj可以借用slice方法,将伪数组转换成数组// var arr = [].slice.apply(obj, [0]);console.log(arr1); // [\"add\",\"ae\",\"erf\",\"wer\"]// 方法二：push()var arr = []; [].push.apply(arr,obj);// == Array.prototype.push.apply(arr,obj) == new Array().push.apply(arr,obj); console.log(arr); [\"add\",\"ae\",\"erf\",\"wer\"] 补充在做jQuery实例化时，发现可以借用上述的方法，将一个伪数组（对象）的所有元素，放在一个空对象（this）中1234var obj1 = &#123;&#125;;[].push.apply(obj1, obj);obj1.length = obj.length; // 注意：这一行代码不可省略。console.log(obj1);","tags":[]},{"title":"","date":"2017-04-08T13:09:56.566Z","path":"2017/04/08/详解JS之this的不同指向/","text":"详解JS中this的几种不同指向如何理解this A this value is a special object which is related with the execution context. Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated). this是和执行上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象(激活执行上下文的上下文)。 a this value is a property of the execution context, but not a property of the variable object。this是执行上下文环境的一个属性，而不是某个变量对象的属性。这个特点很重要，因为和变量不同，this是没有 一个类似搜寻变量的过程。当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决中进入上下文时的情况。本文列举了this在js中的几种情况，以供参考。 1.构造函数中的this指向实例对象12345function Person(info)&#123; this.info = info console.log(this); // stu1&#125;var stu1 = new Person(\"hello\"); 2.原型方法中的this指向构造函数实例化的对象，与构造函数中的this指向相同12345678 function Person(info)&#123; this.info = info &#125; Person.prototype.showInfo = function()&#123;console.log(this); // stu1 &#125; var stu1 = new Person(\"hello\"); stu1.showInfo(); // 调用原型方法 3.在非严格模式下，普通函数中的this指向window；严格模式下指向undefined12345678function f00() &#123; console.log(this == window); // true&#125;function foo2() &#123; use strict console.log(this); // undefined&#125; 4.对象方法中的this就是调用方法的对象（实际上就是方法前面紧挨着的对象）1234567var obj = &#123; info : 'nihao', showInfo : function()&#123; console.log(this.info); // nihao &#125;&#125;;obj.showInfo(); 5.事件方法中的this指的是绑定事件的对象1&lt;input type=\"button\" id=\"btn\" value=\"按钮\"&gt; 123document.getElementById(\"btn\").onclick = function()&#123; this.value = \"点击按钮\" //&#125; 6.定时函数中的this指的是window123window.setInterval(function()&#123; console.log(this); // window setInterval()默认是window的属性，此处的window可省略&#125;) 7.call/apply/bind所调用的函数中的this就是call或者apply的第一个参数（该参数必须是引用类型） 注意：bind方法是ES5的新特性（函数的柯里化），bind用来改变函数内部的this指向，但是不调用函数，并且bind会返回一个新的函数（其实还是原来的函数内容，但是this变成了bind的第一个参数—必须是引用类型） 1234567891011121314151617//call/apply的基本用法 function foo(a,b)&#123; console.log(a + b); &#125; foo.call(null,1,2); foo.apply(null,[1,2]); //如果第一个参数时obj,则会改变this指向 var obj1 = &#123; info : 'Tom' &#125;; var showInfo = function(a,b)&#123; console.log(this.info+(a+b)); //Tom3&#125;; showInfo.call(obj1,1,2); //调用call或apply都会自动执行对应的函数，而bind不会执行对应的函数，只是返回了对函数的引用var result = showInfo.bind(&#123;info:'hello'&#125;,12,13);setTimeout(result,1000); 注意：函数中的this取决于函数的调用方式，与函数的定义方式无关","tags":[]},{"title":"Hello World","date":"2017-04-08T11:32:53.106Z","path":"2017/04/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"详解JS中this的几种不同指向","date":"2016-11-08T13:16:40.000Z","path":"2016/11/08/node使用/","text":"如何理解this A this value is a special object which is related with the execution context. Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated). this是和执行上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象(激活执行上下文的上下文)。 a this value is a property of the execution context, but not a property of the variable object。this是执行上下文环境的一个属性，而不是某个变量对象的属性。这个特点很重要，因为和变量不同，this是没有 一个类似搜寻变量的过程。当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决中进入上下文时的情况。本文列举了this在js中的几种情况，以供参考。 1.构造函数中的this指向实例对象12345function Person(info)&#123; this.info = info console.log(this); // stu1&#125;var stu1 = new Person(\"hello\"); 2.原型方法中的this指向构造函数实例化的对象，与构造函数中的this指向相同12345678 function Person(info)&#123; this.info = info &#125; Person.prototype.showInfo = function()&#123;console.log(this); // stu1 &#125; var stu1 = new Person(\"hello\"); stu1.showInfo(); // 调用原型方法 3.在非严格模式下，普通函数中的this指向window；严格模式下指向undefined12345678function f00() &#123; console.log(this == window); // true&#125;function foo2() &#123; use strict console.log(this); // undefined&#125; 4.对象方法中的this就是调用方法的对象（实际上就是方法前面紧挨着的对象）1234567var obj = &#123; info : 'nihao', showInfo : function()&#123; console.log(this.info); // nihao &#125;&#125;;obj.showInfo(); 5.事件方法中的this指的是绑定事件的对象1&lt;input type=\"button\" id=\"btn\" value=\"按钮\"&gt; 123document.getElementById(\"btn\").onclick = function()&#123; this.value = \"点击按钮\" //&#125; 6.定时函数中的this指的是window123window.setInterval(function()&#123; console.log(this); // window setInterval()默认是window的属性，此处的window可省略&#125;) 7.call/apply/bind所调用的函数中的this就是call或者apply的第一个参数（该参数必须是引用类型） 注意：bind方法是ES5的新特性（函数的柯里化），bind用来改变函数内部的this指向，但是不调用函数，并且bind会返回一个新的函数（其实还是原来的函数内容，但是this变成了bind的第一个参数—必须是引用类型） 1234567891011121314151617//call/apply的基本用法 function foo(a,b)&#123; console.log(a + b); &#125; foo.call(null,1,2); foo.apply(null,[1,2]); //如果第一个参数时obj,则会改变this指向 var obj1 = &#123; info : 'Tom' &#125;; var showInfo = function(a,b)&#123; console.log(this.info+(a+b)); //Tom3&#125;; showInfo.call(obj1,1,2); //调用call或apply都会自动执行对应的函数，而bind不会执行对应的函数，只是返回了对函数的引用var result = showInfo.bind(&#123;info:'hello'&#125;,12,13);setTimeout(result,1000); 注意：函数中的this取决于函数的调用方式，与函数的定义方式无关","tags":[{"name":"js this使用","slug":"js-this使用","permalink":"http://yoursite.com/tags/js-this使用/"}]}]